<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript运算符</title>
    <style type="text/css" media="all">
      body {
        margin: 0;
        font-family: "Helvetica Neue", Helvetica, Arial, "Hiragino Sans GB", sans-serif;
        font-size: 14px;
        line-height: 20px;
        color: #777;
        background-color: white;
      }
      .container {
        width: 700px;
        margin-right: auto;
        margin-left: auto;
      }

      .post {
        font-family: Georgia, "Times New Roman", Times, "SimSun", serif;
        position: relative;
        padding: 70px;
        bottom: 0;
        overflow-y: auto;
        font-size: 16px;
        font-weight: normal;
        line-height: 25px;
        color: #515151;
      }

      .post h1{
        font-size: 50px;
        font-weight: 500;
        line-height: 60px;
        margin-bottom: 40px;
        color: inherit;
      }

      .post p {
        margin: 0 0 35px 0;
      }

      .post img {
        border: 1px solid #D9D9D9;
      }

      .post a {
        color: #28A1C5;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="post">
        <h1 class="title">JavaScript运算符</h1>
        <div class="show-content">
          <h1>算数运算符</h1><h4><b>运算符 + - * / %</b></h4><p><b>+ 加号运算符</b></p><p>功能：</p><p>1.对数字代数求和</p><p>2.对字符串进行连接</p><p>3.将一个数值转换成字符串 ——&gt;数值+""</p><p>注意：任何数据类型+字符串都等于字符串</p><p>字符串拼接时：</p><p>数值+字符串——&gt;将数值直接转为字符串拼接</p><p>字符串+字符串——&gt;两者直接拼接</p><p><b>- 减号运算符</b></p><p>功能：</p><p>1.对数值进行减法操作；</p><p>2.对操作数进行“取反”操作；</p><p>3.将字符串转换成数值；数值型字符串-0=该数值，非数值-0==NaN</p><p><b>*  / 乘号、除号运算符</b></p><p>功能：对两个数进行乘法或除法运算</p><p>正负规则：同号为正，异号得负</p><p><b>% 取余运算符</b></p><p>两个数相除取余数。</p><p>余数是正还是负，和第一个运算数的符号相同</p><h4>复合赋值运算符  += -= *=  /= %=</h4><p>分别相加、相减、相乘、相除和取余后赋值。</p><hr><h1>自增和自减运算符</h1><h4>
<b>++  </b><b>--</b>
</h4><p>对唯一的运算数进行递增或者递减操作（每次加1或者减1）</p><p>注意点：</p><p>1.运算数必须是一个变量、数组的一个元素或者对象的属性</p><p>2.如果运算数是非数值则运算符会将它转成数值直接返回，不会再+或-</p><p>3.符号位置决定运算结果：</p><p>运算数之前——&gt;先进行递增或者递减，再进行求值</p><p>运算数之后——&gt;先求值，再进行递增或者递减操作</p><hr><h1>关系运算符（比较运算符）</h1><h4>大小运算 &gt;  &lt;  &gt;=  &lt;=</h4><p>如果左边  大于/小于/大于等于/小于等于  右边，返回true，否则返回false</p><p>操作规则：</p><p>1.数值与数值比较——&gt;比较代数值</p><p>2.仅一个运算数是数值——&gt;将另一个运算数转成数值，并比较它们的代数值</p><p>3.字符串与字符串——&gt;逐个字符比较它们的Unicode数值</p><p>4.字符串与非数值——&gt;将运算数转换成字符串进行Unicode比较</p><p>5.运算数即非数字也非字符串——&gt;转换成数字或者字符串后进行比较</p><p>6.运算数无法转换成数值或者字符串——&gt;返回false</p><p>7.与NaN比较——&gt;返回false</p><h4>等值运算</h4><p><b>相等比较==    !=</b></p><p>比较两个运算符的返回值，看返回值是否相等或不等</p><p>存在类型转换：</p><p>布尔值：true-----1；false-----0;</p><p>对象：调用valueOf()</p><p>字符串与数值比较：字符串转换成数值</p><p>比较原则：</p><p>1.null与undefined相等</p><p>2.NaN不等于任何数值，包括自身</p><p>3.对象，是不是同一对象，是的话 == 是true</p><p><b>相同比较  ===   !==</b></p><p>不存在隐示类型转换的绝对等于和绝对不等于，比较两个运算数的返回值及数据类型是否相同或不同</p><p>比较原则：</p><p>1.只有数据类型和数值相同才为相同</p><p>2.原始值和引用值之间是绝对不等于</p><p>3.引用值之间比较的是它们的引用（内存地址）</p><hr><h1>对象运算符</h1><p>in：判断左边是否是右边的成员</p><p>instancesof：判断左边对象实例是否是右边的这个类或构造函数构造出来的</p><p>new：创建并初始化一个新的对象</p><p>delete：删除指定对象的属性，数组元素或者变量</p><p>.和[]：存取对象和数组元素</p><p>()：函数调用，改变运算符的优先级等    </p><hr><h1>逻辑运算符</h1><h4>&amp;&amp;逻辑与</h4><p>规则：</p><p>1.第一个操作数是对象，返回第二个；</p><p>2.第一个操作数值为true，第二个为对象时，返回第二的对象；</p><p>3.两个都是对象时，返回第二个；</p><p>4.其中一个操作数是null或者undefined或者NaN时，对应返回null、undefined、NaN，如果同时是这三个值中的两个，返回第一个数；（暂时感觉0也是这个规律）</p><p>特性：</p><p>1.当且仅当两个运算数的值为true时，返回true，否则返回false；</p><p>2.短路操作：当第一个操作数的值是false时，则不再对第二个操作数进行求值了，返回第一个。</p><h4>|| 逻辑或</h4><p>规则：</p><p>1.第一个操作数是对象，返回第一个；</p><p>2.第一个操作数值为false，返回第二个；</p><p>3.两个都是对象时，返回第一个；</p><p>4.两个操作数是null或者undefined或者NaN时，对应返回null、undefined、NaN（0也是这个规律）</p><p>特性：</p><p>1.当且仅当两个运算数的值为false时，返回false，否则返回true；</p><p>2.短路操作：当第一个操作数的值是true时，则不再对第二个操作数进行求值了，返回第一个。</p><h4>!逻辑非</h4><p>非运算符返回值的为true的有：undefined、null、NaN、0、""</p><p>false的有：对象、非空字符串、非0数值</p><p>特性：</p><p>1.当运算的值为false则返回true，否则返回false。</p><p>2.连续使用两次，可将任意类型转成布尔值（true or false）。</p><hr><h1>位运算符<br>
</h1><p><b>基础知识：</b></p><p>1.类型：</p><p>(1).有符号：数字位是 前31位  ，符号位是第32位</p><p>(2).无符号：只能是正数，第32位表示数值，数值范围可以加大</p><p>2.数值范围：-2147483648到2147483647</p><p>3.存储方式：</p><p>正数：纯二进制存储，31位中每一位表示2的幂，用0补充无用位</p><p>负数：2进制补码存储，<b>补码的计算步骤：</b></p><p>(1.确定该数字的非负版本的二进制表示（例如，要计算 -18的二进制补码，首先要确定 18 的二进制表示）</p><p>(2.求得二进制反码，即要把 0 替换为 1，把 1 替换为 0</p><p>(3.在二进制反码上加 1</p><p>4.当做0来处理的特殊值NaN和Infinity</p><p><b>逻辑位运算</b>：</p><p>返回值为1的：按位非~0、按位与&amp;对应位全是1、按位或| 任何一位是1、按位异或^ 即不同时为1也不同时为0    </p><p>返回值为0的：按位非~1、按位与&amp;任意一位是0、按位或| 对应位全位0、按位异或^ 对应位全0或全1    </p><p><b>位移操作：</b></p><p>左移&lt;&lt;：将数值的所有位左移指定的位数，所有空位用0补充。左移1位对其乘2，左移2位对其乘4，以此类推；</p><p>有符号右移&gt;&gt;：将数值的所有位右移指定的位数，移出的位被舍弃，保留符号位，右移1位对其除2，右移2位对其除4，以此类推（在舍弃移出位后的基础上除）；</p><p>无符号右移&gt;&gt;&gt;：</p><p>正数：与有符号右移结果相同</p><p>负号：会出现无限大的数值</p><p><b>复合赋值运算符 </b></p><p>位操作符与等号结合，复合赋值不会有性能方面的提升   </p><hr><h1><b>其他运算符</b></h1><p>1.<b>？: </b> 条件运算符，又叫三目运算符，是简洁的if else</p><p>2.<b>typeof</b> 类型判定运算符</p><p>3.<b>，</b>逗号操作符，在一行语句中执行多个不同的操作，特殊的（1,2）会看一眼第一个，然后返回第二个数。</p><p><br></p><hr><p>*以下是关于位运算符知识，来至于官方文档：<a href="http://www.w3school.com.cn/js/pro_js_operators_bitwise.asp" target="_blank">ECMAScript 位运算符</a></p><p>位运算符是在数字底层（即表示数字的 32 个数位）进行操作的。</p><p>ECMAScript 整数有两种类型，即有符号整数（允许用正数和负数）和无符号整数（只允许用正数）。在 ECMAScript 中，所有整数字面量默认都是有符号整数，</p><p>有符号整数使用 31 位表示整数的数值，用第 32 位表示整数的符号，0 表示正数，1 表示负数。数值范围从 -2147483648 到 2147483647。</p><p>可以以两种不同的方式存储二进制形式的有符号整数，一种用于存储正数，一种用于存储负数。正数是以真二进制形式存储的，前 31 位中的每一位都表示 2 的幂，从第 1 位（位 0）开始，表示 20，第 2 位（位 1）表示 21。没用到的位用 0 填充，即忽略不计。</p><p>负数也存储为二进制代码，不过采用的形式是二进制补码。计算数字二进制补码的步骤有三步：</p><p>1.确定该数字的非负版本的二进制表示（例如，要计算 -18的二进制补码，首先要确定 18 的二进制表示）</p><p>2.求得二进制反码，即要把 0 替换为 1，把 1 替换为 0</p><p>3.在二进制反码上加 1</p><p>有趣的是，把负整数转换成二进制字符串后，ECMAScript 并不以二进制补码的形式显示，而是用数字绝对值的标准二进制代码前面加负号的形式输出。</p><p>var iNum = -18;</p><p>iNum.toString(2);//输出 "-10010"</p><p>这段代码输出的是 "-10010"，而非二进制补码，这是为避免访问位 31。为了简便，ECMAScript 用一种简单的方式处理整数，使得开发者不必关心它们的用法。</p><p>另一方面，无符号整数把最后一位作为另一个数位处理。在这种模式中，第 32 位不表示数字的符号，而是值 231。由于这个额外的位，无符号整数的数值范围为 0 到 4294967295。对于小于 2147483647 的整数来说，无符号整数看来与有符号整数一样，而大于 2147483647 的整数则要使用位 31（在有符号整数中，这一位总是 0）。</p><p>把无符号整数转换成字符串后，只返回它们的有效位。</p><p>注意：所有整数字面量都默认存储为有符号整数。只有 ECMAScript 的位运算符才能创建无符号整数。</p><p><b>~位运算 NOT</b></p><p>位运算 NOT 由否定号（~）表示</p><p>~位运算 三步的处理过程：</p><p>1.把运算数转换成 32 位数字</p><p>2.把二进制数转换成它的二进制反码</p><p>3.把二进制数转换成浮点数</p><p>注：~位运算 实质上是对数字求负，然后减 1</p><p><b>&amp; 位运算 AND</b></p><p>位运算 AND 由和号（&amp;）表示，直接对数字的二进制形式进行运算。它把每个数字中的数位对齐，然后用对应的规则对同一位置上的两个数位进行 AND 运算（两个1才为1，否则为0）</p><p><b>| 位运算 OR</b></p><p>位运算 OR 由符号（|）表示，也是直接对数字的二进制形式进行运算。在计算每位时，OR 运算符采用OR对应的规则计算（有1即为1，否则为0）</p><p><b>^  位运算 XOR</b></p><p>位运算 XOR 由符号（^）表示，当然，也是直接对二进制形式进行运算。XOR 不同于 OR，当只有一个数位存放的是 1 时，它才返回 1。（相同为0，不同为1）</p><p><b>左移运算 &lt;&lt;</b></p><p>左移运算由两个小于号表示（&lt;&lt;）。它把数字中的所有数位向左移动指定的数量的空位,用 0 填充这些空位。</p><p>注意：左移运算保留数字的符号位，即符号仍然存储在第 32 位中</p><p><b>有符号右移运算    &gt;&gt;</b></p><p>有符号右移运算符由两个大于号表示（&gt;&gt;）。它把 32 位数字中的所有数位整体右移，同时保留该数的符号（正号或负号）。有符号右移运算符恰好与左移运算相反。</p><p>同样，移动数位后会造成空位。这次，空位位于数字的左侧，但位于符号位之后。ECMAScript 用符号位的值填充这些空位，创建完整的数字</p><p><b>无符号右移运算 &gt;&gt;&gt;</b></p><p>无符号右移运算符由三个大于号（&gt;&gt;&gt;）表示，它将无符号 32 位数的所有数位整体右移。对于正数，无符号右移运算的结果与有符号右移运算一样。</p><p>对于负数，情况就不同了。</p><p>无符号右移运算用 0 填充所有空位。对于正数，这与有符号右移运算的操作一样，而负数则被作为正数来处理。</p><p>由于无符号右移运算的结果是一个 32 位的正数，所以负数的无符号右移运算得到的总是一个非常大的数字,如何得到这种结果的呢？</p><p>要实现这一点，需要把这个数字转换成无符号的等价形式 如：-64 &gt;&gt;&gt; 0;</p><p>然后，用 Number 类型的 toString() 获取它的真正的位表示</p>
        </div>
      </div>
    </div>
  </body>
</html>
